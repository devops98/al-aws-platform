AWSTemplateFormatVersion: '2010-09-09'
Description: >
  AWS CloudFormation test EC2 and ECS behind Loadbalancer for a 2-tier applcation using RDS (MySQL)
Mappings:
  AWSInstanceType2Arch:
    t2.micro:
      Arch: 64HVM
  AWSRegionArch2AMI:
    us-east-1:
      64HVM: ami-6edd3078
    us-east-2:
      64HVM: ami-fcc19b99
    us-west-2:
      64HVM: ami-7c803d1c
    eu-west-1:
      64HVM: ami-405f7226
  AWSRegionECSAMI:
    us-east-1:
      ecs: ami-b2df2ca4
    us-east-2:
      ecs: ami-832b0ee6
    us-west-2:
      ecs: ami-022b9262
    eu-west-1:
      ecs: ami-a7f2acc1
  # Elasticsearch
  ## Applied at the point CloudWatch log is sent to the LogStreamer Log Group
  FilterPatternLookup:
    CloudTrail:
      Pattern: ''
    Common:
      Pattern:
        '[host, ident, authuser, date, request, status, bytes, referrer, agent]'
    FlowLogs:
      Pattern:
        '[version, account_id, interface_id, srcaddr != "-", dstaddr != "-",
        srcport != "-", dstport != "-", protocol, packets, bytes, start, end,
        action, log_status]'
    Lambda:
      Pattern: '[timestamp=*Z, request_id="*-*", event]'
    Other:
      Pattern: ''
    SpaceDelimited:
      Pattern: '[]'
    ECS:
      Pattern: '"Container"'

Outputs:
  WebsiteURLCodeDeployLB:
    Description: Website
    Value: !Join ["", [
      !If [cEnableHTTPS, "https", "http"],
      !If [cEnableDNS, !Sub "ec2.${AWS::StackName}.al-labs.co.uk", !Sub "${CodeDeployALB.DNSName}"]]
    ]
  RepoURL:
    Description: Git Repository
    Value: !GetAtt CodeRepo.CloneUrlSsh
  ServiceURL:
    Description: ECS LB URL
    Value: !Join ["", [
      !If [cEnableHTTPS, "https", "http"],
      !If [cEnableDNS, !Sub "ecs.${AWS::StackName}.al-labs.co.uk", !Sub "${CodeDeployALB.DNSName}"]]
    ]
  PipelineUrl:
    Value: !Sub https://console.aws.amazon.com/codepipeline/home?region=${AWS::Region}#/view/${MyAppPipeline}
# These exported values are sent in every request by the lambda function, not sure where they get included
# This value below is already exported but not being picked up by the lambda function
  DomainEndpoint:
    Condition: cEnableElasticSearchLogs
    Value:
      Fn::ImportValue:
        !Sub ${ElasticsearchStack}-DomainEndpointES
Parameters:
  DBAllocatedStorage:
    ConstraintDescription: must be between 5 and 1024Gb.
    Default: '5'
    Description: The size of the database (Gb)
    MaxValue: '1024'
    MinValue: '5'
    Type: Number
  DBClass:
    AllowedValues:
      - db.m1.small
      - db.m1.large
    ConstraintDescription: must select a valid database instance type.
    Default: db.m1.small
    Description: Database instance class
    Type: String
  DBName:
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
    Default: todo
    Description: The database name
    MaxLength: '64'
    MinLength: '1'
    Type: String
  DBPassword:
    AllowedPattern: '[a-zA-Z0-9]*'
    ConstraintDescription: must contain only alphanumeric characters.
    Default: password
    Description: The database admin account password
    MaxLength: '41'
    MinLength: '8'
    NoEcho: 'true'
    Type: String
  DBUsername:
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
    Default: root
    Description: The database admin account username
    MaxLength: '16'
    MinLength: '1'
    NoEcho: 'true'
    Type: String
  ElasticsearchLogs:
    Description: Enable/Disable Elasticsearch
    AllowedValues:
      - Enable
      - Disable
    Default: Disable
    Type: String
  ElasticsearchStack:
    Description: Elasticstack to extend
    MaxLength: '64'
    MinLength: '0'
    Type: String
  InstanceType:
    AllowedValues:
      - t2.micro
      - cc1.4xlarge
    ConstraintDescription: must be a valid EC2 instance type.
    Default: t2.micro
    Description: WebServer EC2 instance type
    Type: String
  KeyName:
    AllowedPattern: '[\x20-\x7E]*'
    ConstraintDescription: can contain only ASCII characters.
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances
    MaxLength: '255'
    MinLength: '1'
    Type: "AWS::EC2::KeyPair::KeyName"
  UseDNS:
    Description: Enable/Disable DNS configurations
    AllowedValues:
      - Enable
      - Disable
    Default: Enable
    Type: String
  UseHTTPS:
    Description: Enable/Disable HTTPs configuration
    AllowedValues:
      - Enable
      - Disable
    Default: Enable
    Type: String

Conditions:
  cEnableDNS: !Equals [!Ref UseDNS, 'Enable']
  cEnableHTTPS: !Equals [!Ref UseHTTPS, 'Enable']
  cEnableElasticSearchLogs: !Equals [!Ref ElasticsearchLogs, 'Enable']

# Resources documentation
# http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html
Resources:
  # TODO: this can be moved to another Cloudformation and use stack exports # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html
  ####################################################################################
  # Start of networking
  ####################################################################################
  myVPC:
    Type: "AWS::EC2::VPC"
    Properties:
      CidrBlock: "10.250.0.0/16"
      InstanceTenancy: "default"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-VPC"
  publicSubnet01:
    Type: AWS::EC2::Subnet
    DependsOn: [myVPC]
    Properties:
      VpcId: !Ref myVPC
      # TODO: DNS is set to: 10.250.0.2
      # I wanted to used: 10.250.1.0/24 but then the server don't have access to DNS server :'(
      # Maybe useful: http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html
      CidrBlock: 10.250.0.0/24
      # TODO: AvailabilityZone as paramenter!
      AvailabilityZone: !Select [0, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PublicSubnet01"
  publicSubnet02:
    Type: AWS::EC2::Subnet
    DependsOn: [myVPC]
    Properties:
      VpcId: !Ref myVPC
      CidrBlock: 10.250.2.0/24
      # TODO: AvailabilityZone as paramenter!
      AvailabilityZone: !Select [1, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PublicSubnet02"
  privateSubnet01:
    Type: AWS::EC2::Subnet
    DependsOn: [myVPC]
    Properties:
      VpcId: !Ref myVPC
      CidrBlock: 10.250.100.0/24
      # TODO: AvailabilityZone as paramenter!
      AvailabilityZone: !Select [0, !GetAZs ""]
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PrivateSubnet01"
  privateSubnet02:
    Type: AWS::EC2::Subnet
    DependsOn: [myVPC]
    Properties:
      VpcId: !Ref myVPC
      CidrBlock: 10.250.101.0/24
      # TODO: AvailabilityZone as paramenter!
      AvailabilityZone: !Select [1, !GetAZs ""]
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PrivateSubnet02"
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    DependsOn: [myVPC]
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-InternetGateway"
  AttachInternetGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    DependsOn: [myVPC, InternetGateway]
    Properties:
      VpcId: !Ref myVPC
      InternetGatewayId: !Ref InternetGateway
  ################
  # Public Route
  InternetPublicRoutingTable:
    Type: "AWS::EC2::RouteTable"
    DependsOn: [myVPC, AttachInternetGateway]
    Properties:
      VpcId: !Ref myVPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-InternetRoutingTable"
  InternetPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: [InternetPublicRoutingTable]
    Properties:
      RouteTableId: !Ref InternetPublicRoutingTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
  PublicSubnet01RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: [publicSubnet01, InternetPublicRoutingTable]
    Properties:
      SubnetId: !Ref publicSubnet01
      RouteTableId: !Ref InternetPublicRoutingTable
  PublicSubnet02RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: [publicSubnet02, InternetPublicRoutingTable]
    Properties:
      SubnetId: !Ref publicSubnet02
      RouteTableId: !Ref InternetPublicRoutingTable
  ####################################################################################
  # End of networking
  ####################################################################################

  ####################################################################################
  # Start of Set Parameter Function
  ####################################################################################
  MyKey:
    Type: AWS::KMS::Key
    Properties:
      Description: Master key used by Parameter Store
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Allow administration of the key
            Effect: Allow
            Principal:
              AWS: !Sub arn:aws:iam::${AWS::AccountId}:root
            Action: "*"
            Resource: '*'
          # Allow EncryptLambda function to use the key
          - Effect: Allow
            Action:
              - kms:Encrypt
            Principal:
              AWS: !GetAtt LambdaRole.Arn
            Resource: "*"
          # TODO: This can be set in the key! but we don't have it here
          - Effect: Allow
            Action:
              - kms:Decrypt
            Principal:
              AWS:
                - !GetAtt CodeDeployLinuxEC2InstanceRole.Arn
                - !GetAtt TaskRole.Arn
            Resource: "*"
  MyKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/${AWS::StackName}-masterkey'
      TargetKeyId: !Ref 'MyKey'

  # Create Log Group to setup the Retention time of Lambda Logs
  EncryptLambdaLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-set-param-store
      RetentionInDays: 1
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-Lambda-SetParamStore
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              # Allow lambda to create log group
              - Effect: "Allow"
                Action:
                  - logs:CreateLogGroup
                Resource:
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
              # Create Log streams and write on it
              - Effect: "Allow"
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-set-param-store"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-set-param-store:*"
              # Allow Lambda Function to set values into Parameters Store in a specific name space
              - Effect: "Allow"
                Action:
                  - ssm:PutParameter
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.db.*'
                  # Used on AWS console to test the function ^.^
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.fn.test'
  EncryptLambda:
    Type: AWS::Lambda::Function
    DependsOn: MyKeyAlias
    Properties:
      FunctionName: !Sub ${AWS::StackName}-set-param-store
      Handler: index.lambda_handler
      Role: !GetAtt 'LambdaRole.Arn'
      Code:
        ZipFile: |
          import base64
          import uuid
          import httplib
          import urlparse
          import json
          import boto3
          import logging

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Response emit
          def send_response(request, response, status=None, reason=None):
            if status is not None:
              response['Status'] = status

            if reason is not None:
              response['Reason'] = reason

            if 'ResponseURL' in request and request['ResponseURL']:
              url = urlparse.urlparse(request['ResponseURL'])
              body = json.dumps(response)
              https = httplib.HTTPSConnection(url.hostname)
              https.request('PUT', url.path+'?'+url.query, body)

            return response

          # Main lambda function.
          def lambda_handler(event, context):
            logger.info('got event{}'.format(event))
            logger.info('got context{}'.format(context))

            response = {
              'StackId': event['StackId'],
              'RequestId': event['RequestId'],
              'LogicalResourceId': event['LogicalResourceId'],
              'Status': 'SUCCESS'
            }

            #Make sure that we have a Resource ID
            if 'PhysicalResourceId' in event:
              response['PhysicalResourceId'] = event['PhysicalResourceId']
            else:
              response['PhysicalResourceId'] = str(uuid.uuid4())

            #Delete action is a NoOp
            if event['RequestType'] == 'Delete':
              logger.warning('Delete Event. Nothing to do!')
              return send_response(event, response)

            # WIP
            if event['RequestType'] == 'Update':
              logger.warning('Update Event. Nothing to do!')
              return send_response(event, response)

            try:
              ResourceProperties = event['ResourceProperties']

              # Save value into parameter store
              psClient = boto3.client('ssm')
              a = {
                'Name': ResourceProperties['ParameterStoreName'],
                'Value': ResourceProperties['Value'],
                'Type': ResourceProperties['Type'],
                'Overwrite': bool(ResourceProperties['Overwrite']) if 'Overwrite' in ResourceProperties else False,
              }

              if 'Description' in ResourceProperties:
                a['Description'] = ResourceProperties['Description']

              if 'KeyId' in ResourceProperties:
                a['KeyId'] =  ResourceProperties['KeyId']

              psClient.put_parameter(**a)

              response['Reason'] = 'The value was successfully encrypted'
            except Exception as e:
              logger.error(e)
              response['Status'] = 'FAILED'
              response['Reason'] = 'Encryption Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'

            return send_response(event, response)
      Runtime: python2.7
      Timeout: '25'
  StoreEncryptedDBPassword:
    Type: 'Custom::SetParameterStore'
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      # KeyId: !Ref 'MyKey'
      KeyId: !Sub "alias/${AWS::StackName}-masterkey"
      ParameterStoreName: !Sub '${AWS::StackName}.db.password'
      Value: !Ref DBPassword
      Description: "DataBase password"
      Type: 'SecureString'
      Overwrite: True
  ####################################################################################
  # End of Set Parameter Function
  ####################################################################################

  ####################################################################################
  # Start of RDS
  ####################################################################################
  DBSubnetGroup:
    Type: "AWS::RDS::DBSubnetGroup"
    DependsOn: [privateSubnet01, privateSubnet02]
    Properties:
      DBSubnetGroupDescription: "RDS Subnet Group"
      SubnetIds: [!Ref privateSubnet01, !Ref privateSubnet02]
  DBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    DependsOn: [EcsSecurityGroup, CodeDeployLinuxEC2SecurityGroup]
    Properties:
      GroupDescription: Allow Internal access to RDS Instances
      VpcId: !Ref myVPC
      SecurityGroupIngress:
        - SourceSecurityGroupId: !Ref EcsSecurityGroup
          FromPort: '3306'
          ToPort: '3306'
          IpProtocol: tcp
        - SourceSecurityGroupId: !Ref CodeDeployLinuxEC2SecurityGroup
          FromPort: '3306'
          ToPort: '3306'
          IpProtocol: tcp
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-DB"
  DBInstance:
    Type: AWS::RDS::DBInstance
    DependsOn: [DBSecurityGroup, DBSubnetGroup]
    Properties:
      AllocatedStorage: !Ref DBAllocatedStorage
      DBInstanceClass: !Ref DBClass
      DBName: !Ref DBName
      VPCSecurityGroups: [!Ref DBSecurityGroup]
      Engine: MySQL
      MasterUserPassword: !Ref DBPassword
      MasterUsername: !Ref DBUsername
      BackupRetentionPeriod: 0 # NOTE: This disables backups and speedups the provisioning tests...!
      DBSubnetGroupName: !Ref DBSubnetGroup
  StoreDBAddress:
    Type: 'Custom::SetParameterStore'
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      ParameterStoreName: !Sub '${AWS::StackName}.db.connectionstring'
      Value: !GetAtt DBInstance.Endpoint.Address
      Description: "DataBase Address"
      Type: 'String'
      Overwrite: True
  StoreDBUsername:
    Type: 'Custom::SetParameterStore'
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      # KeyId: !Ref 'MyKey'
      ParameterStoreName: !Sub '${AWS::StackName}.db.username'
      Value: !Ref DBUsername
      Description: "DataBase username"
      Type: 'String'
      Overwrite: True
  StoreDBName:
    Type: 'Custom::SetParameterStore'
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      ParameterStoreName: !Sub '${AWS::StackName}.db.name'
      Value: !Ref DBName
      Description: "DataBase Name"
      Type: 'String'
      Overwrite: True
  ####################################################################################
  # End of RDS
  ####################################################################################

  #####################################################################################
  # Start of ECS
  #####################################################################################
  ContainerCluster:
    Type: "AWS::ECS::Cluster"
    Properties:
      ClusterName: !Sub "${AWS::StackName}-cluster"
  # complete example http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-ecs.html
  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn: [publicSubnet01, publicSubnet02, AttachInternetGateway]
    Properties:
      VPCZoneIdentifier: [!Ref publicSubnet01, !Ref publicSubnet02]
      LaunchConfigurationName: !Ref ContainerInstances
      MinSize: 2
      MaxSize: 10
      DesiredCapacity: 3
      MetricsCollection:
        - Granularity: "1Minute"
          # No metrics specified, send all!
          # http://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_EnableMetricsCollection.html
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ECS
          PropagateAtLaunch: True
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'
  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    DependsOn: [EcsSecurityGroup, EC2InstanceProfile]
    Properties:
      # AMI list: http://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html
      InstanceType: t2.micro
      ImageId: !FindInMap [AWSRegionECSAMI, !Ref 'AWS::Region', 'ecs']
      KeyName: !Ref KeyName
      SecurityGroups: [!Ref EcsSecurityGroup]
      IamInstanceProfile: !Ref EC2InstanceProfile
      InstanceMonitoring: True
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          echo ECS_CLUSTER=${ContainerCluster} >> /etc/ecs/ecs.config
          yum install -y aws-cfn-bootstrap
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
  EcsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    DependsOn: [myVPC]
    Properties:
      GroupDescription: ECS Security Group
      VpcId: !Ref myVPC
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: '31000'
          ToPort: '61000'
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: '22'
          ToPort: '22'
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ECS
  ECSALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    DependsOn: [myVPC]
    Properties:
      GroupDescription: ECS LB Security Group
      VpcId: !Ref myVPC
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: '80'
          ToPort: '80'
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: '443'
          ToPort: '443'
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ECS-LB
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    DependsOn: [EC2Role]
    Properties:
      Path: /
      Roles: [!Ref EC2Role]
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-ECS-EC2
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'ecs:CreateCluster'
                  - 'ecs:DeregisterContainerInstance'
                  - 'ecs:DiscoverPollEndpoint'
                  - 'ecs:Poll'
                  - 'ecs:RegisterContainerInstance'
                  - 'ecs:StartTelemetrySession'
                  - 'ecs:Submit*'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: '*'
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:GetRepositoryPolicy
                  - ecr:DescribeRepositories
                  - ecr:ListImages
                  - ecr:DescribeImages
                  - ecr:BatchGetImage
                Resource: '*'
  ECSServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-ECS-Service
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                  - 'elasticloadbalancing:DeregisterTargets'
                  - 'elasticloadbalancing:Describe*'
                  - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                  - 'elasticloadbalancing:RegisterTargets'
                  - 'ec2:Describe*'
                  - 'ec2:AuthorizeSecurityGroupIngress'
                Resource: '*'
  ECSALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    DependsOn: [publicSubnet01, publicSubnet02, ECSALBSecurityGroup]
    Properties:
      Name: !Sub ${AWS::StackName}-ECS-LB
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets: [!Ref publicSubnet01, !Ref publicSubnet02]
      SecurityGroups: [!Ref ECSALBSecurityGroup]
  ECSTGMyApp:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: [myVPC]
    Properties:
      HealthCheckPath: /
      Name: !Sub ${AWS::StackName}-MyApp
      Port: 3000
      Protocol: HTTP
      VpcId: !Ref myVPC
  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: [ECSTGMyApp, ECSALB]
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ECSTGMyApp
      LoadBalancerArn: !Ref ECSALB
      Port: '80'
      Protocol: HTTP
  MyRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub ${AWS::StackName}-myapp
      RepositoryPolicyText:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowPushPull
            Effect: Allow
            Principal:
              AWS:
                - !Sub arn:aws:iam::${AWS::AccountId}:root
            Action:
              - ecr:GetDownloadUrlForLayer
              - ecr:BatchGetImage
              - ecr:BatchCheckLayerAvailability
              - ecr:PutImage
              - ecr:InitiateLayerUpload
              - ecr:UploadLayerPart
              - ecr:CompleteLayerUpload
  # Crate Log Group to setup the retention time of ECS task logs
  ECSTasksLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${AWS::StackName}-ecs
      RetentionInDays: 1
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-myapp-task-role
      AssumeRolePolicyDocument:
        Statement:
          - Sid: '1'
            Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        # Allow describe parameters to automate config process
        - PolicyName: parameter-store-list
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:DescribeParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:*'
        - PolicyName: parameter-store-db
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.db.*'
        - PolicyName: parameter-store-app
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                  - ssm:PutParameter
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.app.*'
  #####################################################################################
  # End of ECS
  #####################################################################################

  #####################################################################################
  # Start of CI/CD
  #####################################################################################
  QAGroup:
    Type: "AWS::IAM::Group"
    Properties:
      GroupName: !Sub ${AWS::StackName}-QA
      ManagedPolicyArns: ["arn:aws:iam::aws:policy/IAMReadOnlyAccess", "arn:aws:iam::aws:policy/IAMUserSSHKeys"]
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Pull repo
              - Effect: "Allow"
                Action:
                  - codecommit:BatchGetRepositories
                  - codecommit:List*
                Resource: "*"
              - Effect: Allow
                Action:
                  - codecommit:Get*
                  - codecommit:GitPull
                Resource:
                  - !Sub "arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp"
  DevGroup:
    Type: "AWS::IAM::Group"
    Properties:
      GroupName: !Sub ${AWS::StackName}-Dev
      ManagedPolicyArns: ["arn:aws:iam::aws:policy/IAMReadOnlyAccess", "arn:aws:iam::aws:policy/IAMUserSSHKeys"]
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # List repo
              - Effect: "Allow"
                Action:
                  - codecommit:BatchGetRepositories
                  - codecommit:List*
                Resource: "*"
              # Pull repo
              - Effect: Allow
                Action:
                  - codecommit:Get*
                  - codecommit:GitPull
                  - codecommit:GitPush
                Resource:
                  - !Sub "arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp"
  CodeRepo:
    Type: AWS::CodeCommit::Repository
    Properties:
      RepositoryName: !Sub ${AWS::StackName}-myapp
      RepositoryDescription: A code repo for the app...
  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-CodeBuild
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: [codebuild.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              # Login to ECR
              - Effect: "Allow"
                Action:
                  - ecr:GetAuthorizationToken
                Resource: "*"
              # Publish to ECR
              - Effect: "Allow"
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:CompleteLayerUpload
                  - ecr:InitiateLayerUpload
                  - ecr:PutImage
                  - ecr:UploadLayerPart
                Resource:
                  # TODO: paramenterize pm=test => ImageName
                  - !Sub "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/${AWS::StackName}-myapp"
              # Pull repo
              - Effect: "Allow"
                Action:
                  - codecommit:GitPull
                Resource:
                  # TODO: paramenterize pm=test => RepositoryName
                  - !Sub "arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp"
              # Write build logs
              - Effect: "Allow"
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  # TODO: paramenterize pm=test => ProjectName
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp:log-stream"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp:log-stream:*"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-test:log-stream"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-test:log-stream:*"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-image:log-stream"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-image:log-stream:*"
  MyAppBuildAartifact:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub ${AWS::StackName}-myapp
      Description: A description about my project
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # List of Bukd Environments
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/nodejs:7.0.0
      Source:
        Location: !GetAtt CodeRepo.CloneUrlHttp
        Type: CODEPIPELINE
        BuildSpec: !Sub |
          version: 0.1
          phases:
            build:
              commands:
                - echo Install NodeJS dependencies...
                - npm install --only=prod
          artifacts:
            files:
              - "**/*" # All files recursively
      TimeoutInMinutes: 300 # 5min
  MyAppTestAartifact:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub ${AWS::StackName}-myapp-test
      Description: A description about my project
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # List of Bukd Environments
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/nodejs:7.0.0
      Source:
        Location: !GetAtt CodeRepo.CloneUrlHttp
        Type: CODEPIPELINE
        BuildSpec: !Sub |
          version: 0.1
          phases:
            build:
              commands:
                - echo Install NodeJS dev/test dependencies...
                - npm install --only=dev
                - npm test
      TimeoutInMinutes: 300 # 5min
  MyAppBuildDockerImage:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub ${AWS::StackName}-myapp-image
      Description: A description about my project
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/docker:1.12.1
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: IMAGE_REPO_NAME
            Value: !Sub ${AWS::StackName}-myapp
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
      Source:
        Location: !GetAtt CodeRepo.CloneUrlHttp
        Type: CODEPIPELINE
      TimeoutInMinutes: 300 # 5min
  CodeDeployLinuxEC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    DependsOn: [myVPC]
    Properties:
      GroupDescription: Enable HTTP access via port 80 and SSH access.
      VpcId: !Ref myVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-CodeDeploy
  CodeDeployLinuxEC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-CodeDeploy-EC2
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - ec2:*
                  - codedeploy:*
                  - autoscaling:Describe*
                  - cloudformation:Describe*
                  - cloudformation:GetTemplate
                  - s3:Get*
                  - codepipeline:*
                  - rds:DescribeDBInstances
                Resource: '*'
              # Allow fetch from Parameters Store in a specific name space
              - Effect: "Allow"
                Action:
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.db.*'
              # Allow describe parameters to automate config process
              - Effect: "Allow"
                Action:
                  - ssm:DescribeParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:*'
      Path: /
  CodeDeployLinuxEC2InstanceRoleInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    DependsOn: [CodeDeployLinuxEC2InstanceRole]
    Properties:
      Path: /
      Roles: [!Ref CodeDeployLinuxEC2InstanceRole]
  CodeDeployTrustRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-CodeDeploy
      AssumeRolePolicyDocument:
        Statement:
          - Sid: '1'
            Effect: Allow
            Principal:
              Service: [codedeploy.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-CodeDeploy-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Allow CodeDeploy to deploy code into EC2
              - Effect: Allow
                Action:
                  - ec2:*
                  - autoscaling:* # something is required for CodeDeployDefault.AllAtOnce
                Resource: "*"
      Path: /
  CodeDeployAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn: [publicSubnet01, publicSubnet02, CodeDeployInstances, CodeDeployTG]
    Properties:
      VPCZoneIdentifier: [!Ref publicSubnet01, !Ref publicSubnet02]
      LaunchConfigurationName: !Ref CodeDeployInstances
      MinSize: 2
      MaxSize: 10
      DesiredCapacity: 3
      TargetGroupARNs: [!Ref CodeDeployTG]
      MetricsCollection:
        - Granularity: "1Minute"
          # No metrics specified, send all!
          # http://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_EnableMetricsCollection.html
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-CodeDeploy
          PropagateAtLaunch: True
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'
  CodeDeployInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        services:
          sysvint:
            codedeploy-agent:
              enabled: 'true'
              ensureRunning: 'true'
    Properties:
      ImageId: !FindInMap [AWSRegionArch2AMI, !Ref 'AWS::Region', !FindInMap [AWSInstanceType2Arch, !Ref InstanceType, Arch]]
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      SecurityGroups: [!Ref CodeDeployLinuxEC2SecurityGroup]
      IamInstanceProfile: !Ref CodeDeployLinuxEC2InstanceRoleInstanceProfile
      InstanceMonitoring: True
      UserData:
        'Fn::Base64': !Sub |
          #!/bin/bash -ex

          # We can "trap" errors and use cfn-signal to "stop" the deploy

          # Intall CloudFormation tools....
          apt install -y python-setuptools
          mkdir aws-cfn-bootstrap-latest
          curl https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-latest.tar.gz | tar xz -C aws-cfn-bootstrap-latest --strip-components 1
          easy_install aws-cfn-bootstrap-latest

          apt-get update
          apt-get install -y python-pip ruby wget
          # Used to get aws to describe RDS to get conneciton string!
          pip install awscli

          cd /home/ubuntu

          curl -O https://aws-codedeploy-${AWS::Region}.s3.amazonaws.com/latest/install
          chmod +x ./install
          ./install auto

          # https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions
          curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -
          apt-get install -y nodejs

          apt install -y mysql-client

          # All is well, so signal AutoScalingGroup.
          $(which cfn-signal) -e 0 --stack ${AWS::StackName} --resource CodeDeployAutoScalingGroup --region ${AWS::Region}
  CodeDeployALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    DependsOn: [myVPC]
    Properties:
      GroupDescription: CodeDeploy LB Security Group
      VpcId: !Ref myVPC
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: '80'
          ToPort: '80'
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: '443'
          ToPort: '443'
  CodeDeployALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    DependsOn: [publicSubnet01, publicSubnet02, CodeDeployALBSecurityGroup]
    Properties:
      Name: !Sub ${AWS::StackName}-CodeDeploy-LB
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets: [!Ref publicSubnet01, !Ref publicSubnet02]
      SecurityGroups: [!Ref CodeDeployALBSecurityGroup]
  CodeDeployTG:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: [myVPC]
    Properties:
      Name: !Sub ${AWS::StackName}-CodeDeployTG
      Port: 3000
      Protocol: HTTP
      VpcId: !Ref myVPC
  CodeDeployALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: [CodeDeployTG, CodeDeployALB]
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref CodeDeployTG
      LoadBalancerArn: !Ref CodeDeployALB
      Port: '80'
      Protocol: HTTP
  MyAppDeployApplication:
    Type: "AWS::CodeDeploy::Application"
  MyAppDeployApplicationmentGroup:
    Type: "AWS::CodeDeploy::DeploymentGroup"
    DependsOn: [MyAppDeployApplication, CodeDeployAutoScalingGroup, CodeDeployTrustRole]
    Properties:
      ApplicationName: !Ref MyAppDeployApplication
      DeploymentConfigName: "CodeDeployDefault.HalfAtATime"
      AutoScalingGroups: [!Ref CodeDeployAutoScalingGroup]
      ServiceRoleArn: !GetAtt CodeDeployTrustRole.Arn
  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-CodePipelineServiceRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: [codepipeline.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Pull repo
              - Effect: "Allow"
                Action:
                  - codecommit:BatchGetRepositories
                  - codecommit:Get*
                  - codecommit:GitPull
                  - codecommit:List*
                  - codecommit:UploadArchive
                Resource:
                  # TODO: paramenterize pm=test => RepositoryName
                  - !Sub "arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp"
              - Effect: Allow
                Action:
                  - ecr:BatchGetImage
                Resource:
                  - !Sub "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/${AWS::StackName}-myapp"
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                  - cloudformation:*
                  - iam:PassRole
                Resource: "*"
              - Effect: Allow
                Action:
                  - codedeploy:*
                Resource: "*"
  ArtifactStoreS3Location:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      BucketName: !Sub ${AWS::StackName}-codepipeline-artifacts
  ArtifactStoreS3LocationPolicy:
    Type: "AWS::S3::BucketPolicy"
    DependsOn: [ArtifactStoreS3Location]
    Properties:
      Bucket: !Ref ArtifactStoreS3Location
      PolicyDocument:
        Statement:
          - Effect: "Allow"
            Action:
              - s3:*
            Resource:
              - !Sub "arn:aws:s3:::${AWS::StackName}-codepipeline-artifacts"
              - !Sub "arn:aws:s3:::${AWS::StackName}-codepipeline-artifacts/*"
            Principal: "*"
  CloudFormationExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-CloudFormationExecutionRole
      AssumeRolePolicyDocument:
        Statement:
          - Sid: '1'
            Effect: Allow
            Principal:
              Service: [cloudformation.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Resource: "*"
                Effect: Allow
                Action:
                  - ecs:*
                  - ecr:*
                  - iam:*
  MyAppPipeline:
    Type: "AWS::CodePipeline::Pipeline"
    DependsOn:
      - MyAppBuildAartifact
      - MyAppBuildDockerImage
      - MyAppDeployApplication
      - MyAppDeployApplicationmentGroup
      - ContainerCluster
      - ECSTGMyApp
      - ECSServiceRole
      - DBInstance
      - ArtifactStoreS3Location
    Properties:
      Name: !Sub ${AWS::StackName}-MyApp
      RoleArn: !GetAtt CodePipelineServiceRole.Arn
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Version: 1
                Provider: CodeCommit
              OutputArtifacts:
                - Name: SourceOutput
              Configuration:
                RepositoryName: !GetAtt CodeRepo.Name
                BranchName: master
        - Name: Build
          Actions:
            - Name: BuildArtifact
              InputArtifacts:
                - Name: SourceOutput
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              OutputArtifacts:
                - Name: MyAppBuild
              Configuration:
                ProjectName: !Ref MyAppBuildAartifact
              RunOrder: 1
            - Name: TestArtifact
              InputArtifacts:
                - Name: MyAppBuild
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              Configuration:
                ProjectName: !Ref MyAppTestAartifact
              RunOrder: 2
            - Name: BuildDockerImage
              InputArtifacts:
                - Name: SourceOutput
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              OutputArtifacts:
                - Name: DockerImageOutput
              Configuration:
                ProjectName: !Ref MyAppBuildDockerImage
        - Name: Beta
          Actions:
            - Name: BetaEC2
              InputArtifacts:
                - Name: MyAppBuild
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CodeDeploy
              Configuration:
                ApplicationName: !Ref MyAppDeployApplication
                DeploymentGroupName: !Ref MyAppDeployApplicationmentGroup
            - Name: BetaECS
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation
              Configuration:
                ChangeSetName: Deploy
                ActionMode: CREATE_UPDATE
                # StackName: !Ref StackName
                StackName: !Sub ${AWS::StackName}-MyApp-Service
                Capabilities: CAPABILITY_NAMED_IAM
                # TemplatePath: Template::cloudformation.template.myapp.yaml
                TemplatePath: SourceOutput::cloudformation/myapp.template.yaml
                RoleArn: !GetAtt CloudFormationExecutionRole.Arn
                # Can't be a YAML object:  Value of property Configuration must be an object with String (or simple type) properties
                # ParameterOverrides
                #   ECSTGMyApp: !Ref ECSTGMyApp
                #   ECSServiceRole: !Ref ECSServiceRole
                #   DBAddress: !GetAtt DBInstance.Endpoint.Address
                ParameterOverrides: !Sub |
                  {
                    "ParamsPrefix": "${AWS::StackName}",
                    "Cluster": "${ContainerCluster}",
                    "CloudwatchLogsGroup": "${ECSTasksLogsGroup}",
                    "DockerImageTag": { "Fn::GetParam" : ["DockerImageOutput", "build.json", "tag"] },
                    "DockerImage": "${AWS::StackName}-myapp",
                    "TaskRole": "${TaskRole}",
                    "ECSTGMyApp": "${ECSTGMyApp}",
                    "ECSServiceRole": "${ECSServiceRole}",
                    "DBAddress": "${DBInstance.Endpoint.Address}"
                  }
              InputArtifacts:
                - Name: DockerImageOutput
                - Name: SourceOutput
      ArtifactStore:
        Type: S3
        Location: !Ref ArtifactStoreS3Location
  #####################################################################################
  # End of CI/CD
  #####################################################################################

  #####################################################################################
  # Start of Public DNS
  #####################################################################################
  CodeDeployLBCertifcate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub "ec2.${AWS::StackName}.al-labs.co.uk"
      DomainValidationOptions:
        - DomainName: !Sub "ec2.${AWS::StackName}.al-labs.co.uk"
          ValidationDomain: "al-labs.co.uk"
    Condition: cEnableHTTPS
  ECSLBCertifcate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub "ecs.${AWS::StackName}.al-labs.co.uk"
      DomainValidationOptions:
        - DomainName: !Sub "ecs.${AWS::StackName}.al-labs.co.uk"
          ValidationDomain: "al-labs.co.uk"
    Condition: cEnableHTTPS
  CodeDeployALBHTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: [CodeDeployTG, CodeDeployALB, CodeDeployLBCertifcate]
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref CodeDeployTG
      LoadBalancerArn: !Ref CodeDeployALB
      Port: '443'
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref CodeDeployLBCertifcate
    Condition: cEnableHTTPS
  ALBHTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: [ECSTGMyApp, ECSALB, ECSLBCertifcate]
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ECSTGMyApp
      LoadBalancerArn: !Ref ECSALB
      Port: '443'
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref ECSLBCertifcate
    Condition: cEnableHTTPS
  CodeDeployDNSRecord:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneName: al-labs.co.uk.
      Comment: Zone apex alias targeted to myELB LoadBalancer.
      RecordSets:
        # One subdoamin for each type
        - Name: !Sub "ec2.${AWS::StackName}.al-labs.co.uk."
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt CodeDeployALB.CanonicalHostedZoneID
            DNSName: !GetAtt CodeDeployALB.DNSName
        - Name: !Sub "ecs.${AWS::StackName}.al-labs.co.uk."
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt ECSALB.CanonicalHostedZoneID
            DNSName: !GetAtt ECSALB.DNSName
    Condition: cEnableDNS
  #####################################################################################
  # End of Public DNS
  #####################################################################################
  #####################################################################################
  # Start of CloudTrail to CloudWatch
  #####################################################################################
  # Mapping Log groups to the Lambda that ships them to Elasticsearch
  Trail:
    DependsOn: TrailBucketPolicy
    Properties:
      CloudWatchLogsLogGroupArn: !GetAtt TrailLogGroup.Arn
      CloudWatchLogsRoleArn: !GetAtt TrailLogGroupRole.Arn
      IncludeGlobalServiceEvents: true
      IsLogging: true
      IsMultiRegionTrail: true
      S3BucketName:
        Ref: TrailBucket
    Type: AWS::CloudTrail::Trail
  TrailBucket:
    DeletionPolicy: Retain
    Properties: {}
    Type: AWS::S3::Bucket
  TrailBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket:
        Ref: TrailBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action: s3:GetBucketAcl
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Resource: !Sub arn:aws:s3:::${TrailBucket}
          - Action: s3:PutObject
            Condition:
              StringEquals:
                s3:x-amz-acl: bucket-owner-full-control
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Resource: !Sub arn:aws:s3:::${TrailBucket}/AWSLogs/${AWS::AccountId}/*
  TrailLogGroup:
    Properties:
      LogGroupName: !Sub "/aws/cloudtrail/${AWS::StackName}"
      RetentionInDays: '7'
    Type: AWS::Logs::LogGroup
  TrailLogGroupRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
        Version: '2012-10-17'
      Policies:
        - PolicyDocument:
            Statement:
              - Action: logs:CreateLogStream
                Effect: Allow
                Resource: !GetAtt TrailLogGroup.Arn
              - Action:
                  - logs:PutLogEvents
                Effect: Allow
                Resource: !GetAtt TrailLogGroup.Arn
            Version: '2012-10-17'
          PolicyName: cloudtrail-policy
    Type: AWS::IAM::Role
  #####################################################################################
  # End of CloudTrail to CloudWatch
  #####################################################################################
  #####################################################################################
  # Start of Elasticsearch logging domain
  # Logs => CloudWatch logs => CloudWatch/ LogStreamer which triggers lambda
  #####################################################################################
  LambdaInvokePermission:
    Condition: cEnableElasticSearchLogs
    Properties:
      Action: lambda:InvokeFunction
      FunctionName:
        Ref: LogStreamer
      Principal: !Sub logs.${AWS::Region}.amazonaws.com
      SourceAccount:
        Ref: AWS::AccountId
    Type: AWS::Lambda::Permission

## Mapping Log groups to the Lambda that ships them to Elasticsearch
  LogGrouptoLambdaMappingCloudTrail:
    Condition: cEnableElasticSearchLogs
    DependsOn: LambdaInvokePermission
    Properties:
      DestinationArn: !GetAtt LogStreamer.Arn
      FilterPattern: !FindInMap [FilterPatternLookup, CloudTrail, Pattern]
      LogGroupName:
        Ref: TrailLogGroup
    Type: AWS::Logs::SubscriptionFilter

  LogGrouptoLambdaMappingFlowLogs:
    Condition: cEnableElasticSearchLogs
    DependsOn: LambdaInvokePermission
    Properties:
      DestinationArn: !GetAtt LogStreamer.Arn
      FilterPattern: !FindInMap [FilterPatternLookup, FlowLogs, Pattern]
      LogGroupName:
        Ref: VPCFlowLogsLogGroup
    Type: AWS::Logs::SubscriptionFilter

  LogRole:
    Condition: cEnableElasticSearchLogs
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - ec2.amazonaws.com
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - logs:Create*
                  - logs:PutLogEvents
                  - s3:GetObject
                Effect: Allow
                Resource:
                  - arn:aws:logs:*:*:*
                  - arn:aws:s3:::*
            Version: '2012-10-17'
          PolicyName: LogRolePolicy
    Type: AWS::IAM::Role

  LogRoleInstanceProfile:
    Condition: cEnableElasticSearchLogs
    Properties:
      Path: /
      Roles:
        - Ref: LogRole
    Type: AWS::IAM::InstanceProfile

  # Exported so service stacks can stream logs to it.
  LogStreamer:
    Condition: cEnableElasticSearchLogs
    Properties:
      Code:
        S3Bucket: !Sub solutions-${AWS::Region}
        S3Key: centralized-logging/v1/centralizedLoggingDownload.zip
      Description: Lambda function for moving log data to AES.
      Handler: index.handler
      Role: !GetAtt LogStreamerRole.Arn
      Runtime: nodejs4.3
      Timeout: '300'
    Type: AWS::Lambda::Function
  LogStreamerRole:
    Condition: cEnableElasticSearchLogs
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Effect: "Allow"
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}*'
              - Effect: Allow
                Action:
                  - es:ESHttpPost
                Resource: arn:aws:es:*:*:*
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                  - Cloudformation:ListStackResources
                Resource: !Sub 'arn:aws:cloudformation:${AWS::Region}:${AWS::AccountId}*'
            Version: "2012-10-17"
          PolicyName: My_Lambda_Function_Permissions
    Type: AWS::IAM::Role
  MyFlowLog:
    Condition: cEnableElasticSearchLogs
    Properties:
      DeliverLogsPermissionArn: !GetAtt flowlogsRole.Arn
      LogGroupName:
        Ref: VPCFlowLogsLogGroup
      ResourceId:
        Ref: myVPC
      ResourceType: VPC
      TrafficType: ALL
    Type: AWS::EC2::FlowLog

  VPCFlowLogsLogGroup:
    Condition: cEnableElasticSearchLogs
    Properties:
      RetentionInDays: 7
    Type: AWS::Logs::LogGroup
  flowlogsRole:
    Condition: cEnableElasticSearchLogs
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - vpc-flow-logs.amazonaws.com
        Version: 2012-10-17
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                  - logs:PutLogEvents
                Effect: Allow
                Resource: "*"
            Version: "2012-10-17"
          PolicyName: LogRolePolicy
    Type: AWS::IAM::Role
###########################################
# End of Elasticsearch logging domain
###########################################
