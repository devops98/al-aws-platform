{
  "Description": "A Cloud Formation template to explore handling of secret values using AWS KMS. A secret entered as a parameter is encrypted by a lambda function and later decrypted by the ec2 web server instance and exposed as a web url.",
  "AWSTemplateFormatVersion": "2010-09-09",
  "Parameters" : {
    "SecretValue": {           
      "Default": "password", 
      "Description": "The secret to hide", 
      "MaxLength": "64", 
      "Type": "String"
    },
    "KeyPairName": {
      "Description": "Name of an existing Amazon EC2 key pair to enable SSH or RDP access to the instances.",
      "Type": "AWS::EC2::KeyPair::KeyName",
      "MinLength": "1",
      "MaxLength": "255",
      "AllowedPattern": "[\\x20-\\x7E]*",
      "ConstraintDescription": "KeyPairName is a required Field and can contain only ASCII characters."
    },
    "SSHLocation": {
      "Description": "The IP address range that can be used to connect using SSH or RDP to the Amazon EC2 instances.",
      "Type": "String",
      "MinLength": "9",
      "MaxLength": "18",
      "Default": "0.0.0.0/0",
      "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})",
      "ConstraintDescription": "Must be a valid IP CIDR range of the form x.x.x.x/x."
    }    
  },
  "Resources":{
    "InstanceRole": {
        "Type": "AWS::IAM::Role",
        "Metadata": {
            "Comment": "Instance Role to permit decryption of values encrypted under a KMS key without any restrictions and to provide Instance Permisions."
        },    
        "Properties": {
            "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                    "Service": [
                        "ec2.amazonaws.com"
                    ]
                    },
                    "Action": [
                    "sts:AssumeRole"
                    ]
                }
                ]
            },
            "Path": "/"
        }
    },
    "InstanceRolePolicies": {
      "Type": "AWS::IAM::Policy",
      "Properties": {
        "PolicyName": "InstanceRole",
        "PolicyDocument": {
          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "autoscaling:Describe*",
                "cloudformation:Describe*",
                "cloudformation:GetTemplate",
                "s3:Get*"
              ],
              "Resource": "*"
            }
          ]
        },
        "Roles": [
          {
            "Ref": "InstanceRole"
          }
        ]
      }
    },
    "InstanceRoleInstanceProfile": {
      "Type": "AWS::IAM::InstanceProfile",
      "Properties": {
        "Path": "/",
        "Roles": [
          {
            "Ref": "InstanceRole"
          }
        ]
      }
    },        
    "LambdaRole": {
        "Type": "AWS::IAM::Role",
        "Metadata": {
            "Comment": "LambdaRole permits encryption of values under a KMS key without any restrictions and allows write to S3 to store the value"
        },
        "Properties": {
            "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": 
                [{
                    "Effect": "Allow",
                    "Principal": { "Service": [ "lambda.amazonaws.com" ] },
                    "Action": [ "sts:AssumeRole" ]
                }]
            }
        }
    },         
    "MyKey" : {
        "Type" : "AWS::KMS::Key",
        "Properties" : {
            "Description" : "A sample key",            
            "KeyPolicy" : {
                "Version": "2012-10-17",
                "Id": "key-default-1",
                "Statement": [
                    {
                    "Sid": "Allow administration of the key",
                    "Effect": "Allow",
                    "Principal": { "AWS": "arn:aws:iam::505076813643:user/xavier.thomas" },
                    "Action": [
                        "kms:Create*",
                        "kms:Describe*",
                        "kms:Enable*",
                        "kms:List*",
                        "kms:Put*",
                        "kms:Update*",
                        "kms:Revoke*",
                        "kms:Disable*",
                        "kms:Get*",
                        "kms:Delete*",
                        "kms:ScheduleKeyDeletion",
                        "kms:CancelKeyDeletion"
                    ],
                    "Resource": "*"
                    },
                    {
                    "Sid": "Allow use of the key",
                    "Effect": "Allow",
                    "Principal": { "AWS": "arn:aws:iam::505076813643:user/xavier.thomas" },
                    "Action": [
                        "kms:Encrypt",
                        "kms:Decrypt",
                        "kms:ReEncrypt*",
                        "kms:GenerateDataKey*",
                        "kms:DescribeKey"
                    ], 
                    "Resource": "*"
                    },
                    {
                    "Sid": "Allow decrypting of any value encrypted under this key.",
                    "Effect": "Allow",
                    "Principal": { "AWS": {"Fn::GetAtt": [ "InstanceRole","Arn" ] } },
                    "Action": [
                        "kms:Decrypt"
                    ],
                    "Resource": "*"
                    },
                    {
                    "Sid": "Allow encrypting under this key.",
                    "Effect": "Allow",
                    "Principal": { "AWS": {"Fn::GetAtt": [ "LambdaRole","Arn" ] } },
                    "Action": [
                        "kms:Encrypt",
                        "kms:GenerateDataKey"
                    ],
                    "Resource": "*"
                    }            
                ]
            }
        }
    },
    "MyKeyAlias" : {
        "Type" : "AWS::KMS::Alias",
        "Properties" : {
            "AliasName" : { "Fn::Sub": "alias/${AWS::StackName}-masterkey" },
            "TargetKeyId" : {"Ref":"MyKey"}
        }
    },    
    "EncryptLambda" : {
        "Type": "AWS::Lambda::Function",
        "Properties": {
            "Handler": "index.lambda_handler",
            "Role": { "Fn::GetAtt" : ["LambdaRole", "Arn"] },
            "Code": {
                "ZipFile": { "Fn::Join": ["\n", [
                    "import base64",
                    "import uuid",
                    "import httplib",
                    "import urlparse",
                    "import json",
                    "import boto3",
                    "def send_response(request, response, status=None, reason=None):",
                    "   if status is not None:",
                    "       response['Status'] = status",
                    "   if reason is not None:",
                    "       response['Reason'] = reason",
                    "   if 'ResponseURL' in request and request['ResponseURL']:",
                    "       url = urlparse.urlparse(request['ResponseURL'])",
                    "       body = json.dumps(response)",
                    "       https = httplib.HTTPSConnection(url.hostname)",
                    "       https.request('PUT', url.path+'?'+url.query, body)",
                    "   return response",
                    "def lambda_handler(event, context):",
                    "   response = {",
                    "       'StackId': event['StackId'],",
                    "       'RequestId': event['RequestId'],",
                    "       'LogicalResourceId': event['LogicalResourceId'],",
                    "       'Status': 'SUCCESS'",
                    "   }",    
                    "   if 'PhysicalResourceId' in event:",
                    "       response['PhysicalResourceId'] = event['PhysicalResourceId']",
                    "   else:",
                    "       response['PhysicalResourceId'] = str(uuid.uuid4())",    
                    "   if event['RequestType'] == 'Delete':",
                    "       return send_response(event, response)",    
                    "   try:",
                    "       for key in ['KeyId', 'PlainText']:",
                    "           if key not in event['ResourceProperties'] or not event['ResourceProperties'][key]:",
                    "               return send_response(",
                    "                   event, response, status='FAILED',",
                    "                   reason='The properties KeyId and PlainText must not be empty'",
                    "               )",
                    "       client = boto3.client('kms')",
                    "       encrypted = client.encrypt(",
                    "           KeyId=event['ResourceProperties']['KeyId'],",
                    "           Plaintext=event['ResourceProperties']['PlainText']",
                    "       )",
                    "       response['Data'] = {",
                    "           'CipherText': base64.b64encode(encrypted['CiphertextBlob'])",
                    "       }",
                    "       response['Reason'] = 'The value was successfully encrypted'",
                    "   except Exception as E:",
                    "       response['Status'] = 'FAILED'",
                    "       response['Reason'] = 'Encryption Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'",
                    "   return send_response(event, response)"
                ]]}
            },
            "Runtime": "python2.7",
            "Timeout": "25"
        }
    },
    "EncryptSecrets": {
      "Type": "AWS::CloudFormation::CustomResource",
      "Version": "1.0",
      "Properties": {
        "ServiceToken": {"Fn::GetAtt": [ "EncryptLambda","Arn" ] },
        "KeyId": {"Ref": "MyKey"},
        "PlainText": {"Ref": "SecretValue"}
      }
    },
    "EC2SecurityGroup": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": "Enable HTTP access via port 80 and SSH access.",
        "SecurityGroupIngress": [
          {
            "IpProtocol": "tcp",
            "FromPort": "80",
            "ToPort": "80",
            "CidrIp": "0.0.0.0/0"
          },
          {
            "IpProtocol": "tcp",
            "FromPort": "22",
            "ToPort": "22",
            "CidrIp": {
              "Ref": "SSHLocation"
            }
          }
        ]
      }
    },    
    "WebServer" : {
      "Type": "AWS::EC2::Instance",      
      "Metadata" : {
          "Comment" : "Install a simple application",
          "AWS::CloudFormation::Init" : {
              "config" : {
                  "packages" : {
                  "apt" : {
                      "nginx" : []
                  }
                  },
                  "files" : {
                  "/var/www/html/index.html" : {
                      "content" : { "Fn::Join" : ["\n", ["<h1>Your Secret is {secret}.</h1>"]]},
                      "mode"    : "000644",
                      "owner"   : "root",
                      "group"   : "root"
                  }
                  },

                  "services" : {
                  "sysvinit" : {
                      "nginx"    : { "enabled" : "true", "ensureRunning" : "true" }
                  }
                  }
              }
          }
      },
      "Properties": {
        "ImageId": "ami-405f7226",
        "InstanceType": "c3.large",        
        "SecurityGroups": [
          {
            "Ref": "EC2SecurityGroup"
          }
        ],
        "KeyName": {
          "Ref": "KeyPairName"
        },        
        "IamInstanceProfile": {
          "Ref": "InstanceRoleInstanceProfile"
        },
        "UserData":{
          "Fn::Base64":{
              "Fn::Join":[
                  "",
                  [
                  "#!/bin/bash -ex\n",
                  "# Install CFN Bootstrap\n",
                  "sudo apt-get -y update\n",                        
                  "sudo apt-get -y install ruby\n",
                  "sudo apt-get -y install wget\n",
                  "sudo apt-get -y install python-pip\n",                        
                  "pip install https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-latest.tar.gz\n",
                  "sudo apt-get -y install awscli \n",
                  "# Call CFN-INIT to process the metadata for CloudFormation Init. Since ubuntu does not have the tools installed, we install the CFN Bootstrap in the previous step.\n",
                  "cfn-init -s ", { "Ref" : "AWS::StackName" }, "  --resource WebServer   --region ", { "Ref" : "AWS::Region" }, "\n",
                  "echo ", {"Fn::GetAtt": ["EncryptSecrets", "CipherText"]}," | base64 --decode > ciphertext \n",                  
                  "aws kms decrypt --region ", { "Ref" : "AWS::Region" }, " --ciphertext-blob fileb://ciphertext --output text --query Plaintext | base64 --decode > plaintext \n",                  
                  "sed -i \"s/{secret}/$(cat plaintext)/g\" /var/www/html/index.html \n"                  
                  ]
              ]
          }
        } 
      }      
    }
  },
  "Outputs": {
    "EncryptedText": {
      "Value": {"Fn::GetAtt": ["EncryptSecrets", "CipherText"]},
      "Description": "KMS encrypted value of the Secret (Base64 encoded)"
      },
    "URL": {
      "Value" : {"Fn::GetAtt":["WebServer","PublicDnsName"]},
      "Description": "URL to view the decrypted secret."        
      }    
  }
}

